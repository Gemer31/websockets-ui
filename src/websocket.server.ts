import { WebSocketServer } from 'ws';
import { AddShipsData, AttackData, IUserWithIndex, IUserWithPassword, Message } from './models';
import { AttackStatus, WsMessageTypes } from './types';
import { UsersController } from './controllers/users.controller';
import { UsersService } from './services/users.service';
import { ShipsController } from './controllers/ships.controller';
import { RoomsService } from './services/roomsService';
import { GameService } from './services/game.service';
import { RoomController } from './controllers/room.controller';

export const usersService = new UsersService();
export const roomsService = new RoomsService();
export const gameService = new GameService();

export const usersController = new UsersController(usersService);
export const roomController = new RoomController(roomsService);
export const shipsController = new ShipsController(usersService);

export const roomsAndClients: Map<string, any[]> = new Map();
export const clientsAndUsers: Map<any, IUserWithIndex> = new Map();
export const gameAndRoom: Map<string, any> = new Map();

export function runWebsocket() {
  const wsServer = new WebSocketServer({port: 3000});

  wsServer.on('connection', (wsClient) => {
    console.log('Web Socket Server connected');

    clientsAndUsers.set(wsClient, null);

    wsClient.on('message', async (msg) => {
      const requestData = JSON.parse(msg.toString()) as Message;

      try {
        switch (requestData.type) {
          case WsMessageTypes.REGISTRATION: {
            const user: IUserWithIndex = await usersController.getUser(JSON.parse(requestData.data as string) as IUserWithPassword);
            clientsAndUsers.set(wsClient, user);
            const responseData = {...requestData, data: JSON.stringify(user)};
            wsClient.send(JSON.stringify(responseData));

            roomController.updateRoom(wsClient);
            usersController.updateWinners(wsClient);
            break;
          }
          case WsMessageTypes.ADD_USER_TO_ROOM: {
            const indexRoom: string = (JSON.parse(requestData.data as string) as { indexRoom: string }).indexRoom;
            roomsService.addUserToRoom(indexRoom, clientsAndUsers.get(wsClient));

            [...clientsAndUsers.keys()].forEach((c) => roomController.updateRoom(c));

            const roomClients = [...roomsAndClients.get(indexRoom), wsClient];
            roomsAndClients.set(indexRoom, roomClients);

            const idGame = gameService.createGame(
              indexRoom,
              roomClients.map((c) => clientsAndUsers.get(c).index),
            );
            roomClients.forEach((c) => {
              c.send(JSON.stringify({
                type: WsMessageTypes.CREATE_GAME, //send for both players in the room, after they are connected to the room
                data: JSON.stringify({
                  idGame,
                  idPlayer: clientsAndUsers.get(c).index, /* generated by server id for player in the game session, not enemy (unique id for every player) */
                }),
                id: 0,
              }));
            });

            break;
          }
          case WsMessageTypes.CREATE_ROOM: {
            const roomId = roomsService.createRoom(clientsAndUsers.get(wsClient));
            roomsAndClients.set(roomId, [wsClient]);
            roomController.updateRoom(wsClient);
            [...clientsAndUsers.keys()].forEach((c) => roomController.updateRoom(c));
            break;
          }
          case WsMessageTypes.ADD_SHIPS: {
            const data: AddShipsData = JSON.parse(requestData.data as string) as AddShipsData;

            gameService.addShips(data.gameId, data.indexPlayer, data.ships);

            if (gameService.gameIsReady(data.gameId)) {
              roomsAndClients.get(gameService.getRoomIdByGameId(data.gameId))
                .forEach((c) => {
                  const indexPlayer: string = clientsAndUsers.get(c).index;

                  c.send(JSON.stringify({
                    type: WsMessageTypes.START_GAME,
                    data: JSON.stringify(
                      {
                        ships: gameService.getPlayerShips(data.gameId, indexPlayer), /* player's ships, not enemy's */
                        currentPlayerIndex: indexPlayer, /* id of the player in the current game session, who have sent his ships */
                      },
                    ),
                    id: 0,
                  }));
                });
            }

            wsClient.send(JSON.stringify({
              type: WsMessageTypes.TURN,
              data: JSON.stringify(
                {
                  currentPlayer: clientsAndUsers.get(wsClient).index, /* id of the player in the current game session */
                },
              ),
              id: 0,
            }));
            break;
          }
          case WsMessageTypes.ATTACK:
          case WsMessageTypes.RANDOM_ATTACK: {
            const data: AttackData = JSON.parse(requestData.data as string) as AttackData;
            const status = gameService.attack(
              data.gameId,
              data.indexPlayer,
              (data.x && data.y) ? {x: data.x, y: data.y} : null,
            );

            roomsAndClients.get(gameService.getRoomIdByGameId(data.gameId))
              .forEach((c) => {
                c.send(JSON.stringify({
                  type: WsMessageTypes.ATTACK,
                  data: JSON.stringify({
                    position: {x: data.x, y: data.y},
                    currentPlayer: data.indexPlayer, /* id of the player in the current game session */
                    status,
                  }),
                  id: 0,
                }));
              });

            if (status === AttackStatus.MISS) {
              roomsAndClients.get(gameService.getRoomIdByGameId(data.gameId))
                .forEach((c) => {
                  c.send(JSON.stringify({
                    type: WsMessageTypes.TURN,
                    data: JSON.stringify({
                      currentPlayer: clientsAndUsers.get(wsClient).index, /* id of the player in the current game session */
                    }),
                    id: 0,
                  }));
                });
            } else {
              // continue
            }

            const winner = gameService.getWinner(data.gameId);
            if (winner) {
              roomsAndClients.get(gameService.getRoomIdByGameId(data.gameId))
                .forEach((c) => {

                  c.send(JSON.stringify({
                    type: WsMessageTypes.FINISH,
                    data: JSON.stringify({
                      winPlayer: winner, /* id of the player in the current game session */
                    }),
                    id: 0,
                  }));

                  usersController.updateWinners(c);
                });
            }
          }
          default: {

          }
        }
      } catch (e) {
        console.log(e);
        // wsClient.send(JSON.stringify({...requestData, error: true, errorText: e}));
      }
    });
  });
}
